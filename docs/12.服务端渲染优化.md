# 服务端渲染优化

在前面的项目架构中，给前端代码加入了 router store 对于服务端渲染也有一定的影响，服务端渲染内容根据不同的router 路径映射，来返回不同的 html 内容

## 路由跳转

使用者可能从任意路由进入我们的网站，所以在服务端中也必须处理路由跳转，再返回给客户端的时候就是指定页面

## store 数据同步

每个页面会有对应的数据，在服务端渲染时已经请求过对应数据，所以要让客户端知道这些数据，在客户端渲染的时候直接使用，而不是通过 API 再次请求，造成浪费

先打开项目 server-entry.js,目前值返回了 `<App/>`,和我们客户端代码已经差别很大了

```js
# !/client/app.js

...
    <AppContainer>
      <Provider appState={appState}>
        <BrowserRouter>
          <Component />
        </BrowserRouter>
      </Provider>
    </AppContainer>,
    root,
...
```

也需要把客户端这些放到服务端渲染中，首先需要使用 react-router `import { StaticRouter } from 'react-router-dom'` StaticRouter 是 react-router 专门做服务端渲染的,接受 context 是做服务端渲染的时候传递的对象，做静态渲染的时候会对这个对象进行操作，然后返回一些信息让我们做对应的操作，比如redirect 到一个地方,第二个参数是 location，现在请求的 url

`import { Provider, useStaticRendering } from 'mobx-react'` 是 mobx 专门做服务端渲染的 `useStaticRendering(true)` 需要先声明做静态渲染

服务端渲染的时候需要生成不同的 store 传递给 Provider

```js
# !/client/server-entry.js

import React from 'react'
import { StaticRouter } from 'react-router-dom'
import { Provider, useStaticRendering } from 'mobx-react'
import App from './views/App'

// 让 mobx 在服务端渲染的时候不会重复的数据变换
useStaticRendering(true)

// {appStore: xxx} 使用 ... 解构的方式
export default (stores, routerContext, url) => {
  return (
    <Provider {...stores}>
      <StaticRouter context={routerContext} location={url}>
        <App />
      </StaticRouter>
    </Provider>
  )
}
```

然后修改下 app-state.js 删除`const appState = new AppState() export default appState` 不需要创建一个实例，所以在 app.js 中就可以 `<Provider appState={new AppState()}>`

```js
# !/client/app.js

import AppState from './store/app-state'
...
const root = document.getElementById('root')
const render = (Component) => { // 使用appState={new AppState()}新建一个实例
  const renderMethod = module.hot ? ReactDOM.render : ReactDOM.hydrate
  renderMethod(
    <AppContainer>
      <Provider appState={new AppState()}>
        <BrowserRouter>
          <Component />
        </BrowserRouter>
      </Provider>
    </AppContainer>,
    root,
  )
}
```

这样做的好处是在服务端渲染的时候每次都要生成新的实例传递给服务端，这样就可以用 class 来生成

```js
# !/client/store/app-state.js

import {
  observable,
  computed,
  // autorun,
  action,
} from 'mobx'

export default class AppState {
  @observable count = 0

  @observable name = 'wangbadan'

  @computed get msg() {
    return `${this.name} say count is  ${this.count}`
  }

  @action add() {
    this.count += 1
  }

  @action changeName(name) {
    this.name = name
  }
}
```

然后来写 store.js 代码

```js
# !/client/store/store.js

import AppStateClass from './app-state'

export const AppState = AppStateClass

export default {
  AppState,
}

export const createStoreMap = () => {
  return {
    appState: new AppState(),
  }
}
```

这个函数 createStoreMap 是专门给服务端渲染做的

然后回到 server-entry.js 首先修改一个地方，因为只return内容没有做逻辑判断,所以把大括号和return去掉，精简代码

```js
# !/client/server-entry.js

import React from 'react'
import { StaticRouter } from 'react-router-dom'
import { Provider, useStaticRendering } from 'mobx-react'
import App from './views/App'
import { createStoreMap } from './store/store'

// 让 mobx 在服务端渲染的时候不会重复的数据变换
useStaticRendering(true)

// {appStore: xxx} 使用 ... 解构的方式
export default (stores, routerContext, url) => (
  <Provider {...stores}>
    <StaticRouter context={routerContext} location={url}>
      <App />
    </StaticRouter>
  </Provider>
)

export { createStoreMap }
```

export createStoreMap 这样在服务端渲染就非常有用了

现在切换到 dev-static.js, 首先把 createStoreMap 这个方法拿进来

```js
# !/server/utils/dev-static.js

...
let serverBundle, createStoreMap
...
  serverBundle = m.exports.default // 通过exports挂载从模块导出来获取 server bundle
  createStoreMap = m.exports.createStoreMap
...
    getTemplate().then(template => {

      const routerContext = {}
      const app = serverBundle(createStoreMap(), routerContext, req.url)

      const content = ReactDomServer.renderToString(app)
      res.send(template.replace('<!-- app -->', content))
    })
...
```

因为我们 server bundle 不是能够直接渲染的内容了，而是一个方法，根据方法来创建渲染内容

这样整个流程大致走通，我们运行 `npm run dev:client` 再新建一个命令行窗口 `npm run dev:server` 访问 localhost:3333 查看 network response

![list ssr body](./img/05.ssr.png)

这是最基本的服务端渲染的内容，然后要考虑路由的 redirect ，打开我们的 router.jsx

我们显示网页源代码 访问 localhost:3333

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>YaK IDE Server Side Render</title>
</head>
<body>
  <div id="root"><div><a href="/">首页</a><br/><a href="/detail">详情页</a></div></div>
<script type="text/javascript" src="/public/app.b6a0c4f3a1b78a7a7750.js"></script></body>
</html>
```

是没有 redirect 到 list 路由下的内容，所以我们修改 dev-static.js 代码,有 redirect 情况下 react-router 是会给 routerContext 增加一个属性叫 url ，如果有这个属性，直接在服务端给 redirect 掉

```js
# !/server/utils/dev-static.js

...
  app.get('*', function (req, res) {
    // 服务端渲染完成的结果返回给浏览器端
    getTemplate().then(template => {
      const routerContext = {}
      const app = serverBundle(createStoreMap(), routerContext, req.url)

      const content = ReactDomServer.renderToString(app)
      // 在renderToString之后拿到 routerContext
      if (routerContext.url) { // 判断routerContext有redirect情况下会增加URL属性
        res.status(302).setHeader('Location', routerContext.url) // 重定向302头
        res.end() // 结束请求 setHeader上增加属性，让浏览器自动跳转到routerContext.url
        return // 不然会继续执行下面的代码
      }

      res.send(template.replace('<!-- app -->', content))
    })
  })
...
```

这样就可以在服务端渲染的时候做好路由跳转[路由跳转的服务端渲染]()

接下来希望服务端渲染的时候拿到异步的数据去渲染内容
